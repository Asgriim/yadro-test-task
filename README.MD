#  Тестовое задание YADRO

- [Сборка и запуск](#build)
- [Режимы работы](#mode)
- [Конфиг](#config)
- [Решение](#sol)
- [Задание](#task)
### <a name="build">Сборка и запуск</a>
```
$ cmake .
$ make 
$ ./tape_sorter in_file out_file
```

### <a name="mode">Режимы работы</a>

Программа может работать в 2 режимах:

1. Бинарный - на вход принимаются бинарные файлы, которые содержат элементы типа int32, в этом режиме обязательно нужно указать размер файла в байтах 3 аргументом.
2. Текстовый - на вход принимаются текстовые файлы лент, где числа разделены знаком `\n`. Размер файла указывать не нужно.

Режим работы задается в файле `config`

Программа может эмулировать реальные задержки ленты, если задать `emulate_latency=1` в файле `config`

По умолчанию программа работает в текстовом режиме без эмуляции задержек.

### <a name="config">Конфиг</a>

- `read_latency` - задержка чтения элемента в миллисекундах.
- `write_latency` - задержка записи элемента в миллисекундах.
- `rewind_latency` - задержка перемотки ленты в миллисекундах.
- `memory_limit` - лимит памяти в байтах. Минимально 8.
- `tmp_tape_limit` - максимальное количесто временных лент. Минимально 3, максимум 30000.
- `emulate_latency` - флаг эмуляции задержек лент.
- `text_mode` - режим работы.
  - Если 1, то текстовый режим.
  - Если 0, то бинарный режим.

### <a name="sol">Решение</a>
Будем считать что перемотка ленты на n позиций это линейная операция и она равна `n * (время сдвига на 1 позицию)` 

Так как мы не можем загрузить всю ленту в ОЗУ, то придется сортировать ленту блоками по M. Чтобы отсортировать массив элементов в памяти будем использовать `merge sort`,
но модифицированный, который использует `O(1)` памяти. Для это нужно написать итеративый `merge sort` (экономим память на стеке) и для самого слияния использовать 
[std::inplace_merge](https://en.cppreference.com/w/cpp/algorithm/inplace_merge). 

После сортировки массива M элементов, запишем его во временную ленту. Саму ленту положим в приоритетную очередь на слияние. 
Как только очередь заполниться до обозначенного лимита будем сливать 2 наименьшие по размеру временные ленты.

Чтобы меньше времени тратить на перемотку временных лент, будем читать их с конца. Это потребует усложнения логики, но даст прирост производительности.

### <a name="task">Задание</a>
Устройство хранения данных типа лента (Tape) предназначено для последовательной записи и
чтения данных. Считывающая/записывающая магнитная головка неподвижна во время чтения и
записи, а лента имеет возможность двигаться в обоих направлениях. Запись и чтение информации
возможны в ячейку ленты, на которой в данный момент находится магнитная головка.
Перемещения ленты – затратная по времени операция – лента не предназначена для
произвольного доступа.

Имеется входная лента длины N (где N – велико), содержащая элементы типа integer (2
32).
Имеется выходная лента такой же длины. Необходимо записать в выходную ленту
отсортированные по возрастанию элементы с входной ленты. Есть ограничение по использованию
оперативной памяти – не более M байт (M может быть < N, т.е. загрузить все данные с ленты в
оперативную память не получится). Для реализации алгоритма можно использовать разумное
количество временных лент, т.е. лент, на которых можно хранить какую-то временную
информацию, необходимую в процессе работы алгоритма.

Необходимо создать проект С++, компилируемый в консольное приложение, которое реализует
алгоритм сортировки данных с входной ленты на выходную. Необходимо сделать следующее:

- Определить интерфейс для работы с устройством типа лента.
- Написать класс, реализующий этот интерфейс и эмулирующий работу с лентой
  посредством обычного файла. Должно быть возможно сконфигурировать (без
  перекомпиляции – например, через внешний конфигурационный файл, который будет
  прочитан на старте приложения) задержки по записи/чтению элемента с ленты, перемотки
  ленты, и сдвига ленты на одну позицию
- Файлы временных лент можно сохранять в директорию tmp
- Написать класс, реализующий алгоритм сортировки данных с входной ленты на выходную.
- Консольное приложение должно принимать на вход имя входного и выходного файлов и
  производить сортировку.
- Желательно написать юнит-тесты.